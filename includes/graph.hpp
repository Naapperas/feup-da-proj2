#ifndef DA_PROJ2_GRAPH_H
#define DA_PROJ2_GRAPH_H

class Graph;

#include <climits>
#include <iostream>
#include <list>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <vector>

/**
 * @brief Represents an edge connecting two nodes.
 */
struct Edge {
    /**
     * @brief The destination node.
     */
    int dest = -1;
    int capacity = -1;
    int duration = -1;

    Edge(const int dest, const int capacity, const int duration)
        : dest(dest), capacity(capacity), duration(duration){};
    Edge(){};

    bool operator==(const Edge &other) const { return dest == other.dest; }
};

namespace std {
    template <> struct hash<Edge> {
        std::size_t operator()(const Edge &e) const { return e.dest; }
    };
}

/**
 * @brief Represents a node in a Graph.
 */
struct Node {
    /**
     * @brief The outgoing edges connecting this node to others.
     */
    std::unordered_map<int, Edge> adj{};

    int label = -1;
    int parent = -1;

    bool visited = false;

    int minTime = INT_MAX, maxTime = INT_MIN;

    // max(incoming-ES) - min(incoming-ES) [scenarios 2.4 and 2.5]
    int waitTime = -1;

    Node(const int label) : label(label){};
    Node(){};
};

/**
 * @brief Holds data from a dataset to be used by different scenarios.
 *
 * @details Also has several static methods to make dataset management easier.
 */
class Graph {
    /**
     * @brief This graph's nodes.
     *
     * The keys are each node's id and the values are the nodes
     * themselves.
     */
    std::unordered_map<int, Node> nodes;

    /**
     * @brief The residual graph resulting from performing flux calculations (related to the Edmonds-Karp algorithm).
     * 
     */
    std::vector<std::vector<int>> residualGraph;

    /**
     * @brief Marks all nodes as unvisited.
     *
     */
    void resetVisits();

public:
    Graph(){};
    Graph(int n) : residualGraph(n + 1, std::vector<int>(n + 1)) {
        for (int i = 1; i <= n; ++i)
            nodes.insert({i, {i}});
    };

    /**
     * @brief Adds an edge between two nodes, identified by their label.
     * 
     * @param src the label of the source node
     * @param dest the label of the destination node
     * @param capacity the capacity of the added edge
     * @param duration the amount of time units needed to traverse the added edge
     */
    void addEdge(const int src, const int dest, const int capacity,
                 const int duration);

    /**
     * @brief Adds an edge between two nodes.
     * 
     * @param src the source node
     * @param dest the destination node
     * @param capacity the capacity of the added edge
     * @param duration the amount of time units needed to traverse the added edge
     */
    void addEdge(Node &src, Node &dest, const int capacity, const int duration);

    /**
     * @return This graph's nodes.
     */
    std::unordered_map<int, Node> &getNodes() { return nodes; };
    /**
     * @brief Get the node with the specified code.
     *
     * @param id The stop code.
     * @return The node.
     */
    Node &getNode(const int &id) { return nodes.at(id); };

    /**
     * @brief Performs a Breadth-First Search algorithm.
     *
     * @param start Starting node
     * @param end Destination node
     * @return the path between <s> and <t> generated by this algorithm and the
     * maximum capacity of that path
     */
    void bfs(int start, int end);

    /**
     * @brief Applies breadth-first-search to the graph when running the
     *        Edmonds-Karp algorithm
     *
     * @param s Starting node
     * @param t Destination node
     * @param parent Array to keep the path
     * @param residualGraph The residual graph of a dataset
     *
     * @return The max flow that is available in the path from s to t
     */
    int edmondsKarpBFS(int s, int t);

    /**
     * @brief Applies the Edmonds-Karp algorithm to this graph
     * 
     * @param start the start node of the intended path
     * @param end the end node of the intended path
     * @param groupSize the desired size of a group traveling through this graph
     * @return std::pair<int, Graph> 
     */
    std::pair<int, Graph> edmondsKarp(int start, int end, int groupSize = INT_MAX);

    /**
     * @brief Checks if an element with the given key exists
     *
     * @param id the number of the node to check
     * @return true if the node belongs to this graph, false otherwise
     */
    bool hasNode(int id) const { return nodes.contains(id); }

    /**
     * @brief Adds a new node associated with the given id
     *
     * @param i the id of the node
     * @param node the node to add
     */
    void addNode(int i, const Node &node);

    /**
     * @brief Adds a new node associated with the given id
     *
     * @param i the id of the node
     */
    void addNode(int i);

    /**
     * @brief Clears this graph
     *
     */
    void clear() { nodes.clear(); };

    void toDotFile(const std::string &path, const std::vector<Graph> paths = {});
};

#endif
